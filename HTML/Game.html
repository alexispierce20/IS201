<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>The Office 2048</title>
  <style>
    /* GLOBAL: blue background behind the white box */
    body {
      margin: 0;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      color: #0d2b6b; /* Dunder Mifflin dark blue */

      background-color: #123a7a; /* fallback solid blue */
      background-image: url("../assets/img/blue-backdrop.png");
      background-repeat: repeat;

      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
    }

    /* WHITE BOX IN THE CENTER (game wrapper) */
    .game-container {
      max-width: 520px;
      width: 100%;
      margin: 2rem auto;
      background-color: #ffffff;
      border-radius: 4px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.25);
      padding: 1.75rem 1.75rem 2rem;
      text-align: center;
    }

    /* HEADER / TITLE BAR */
    .game-header {
      background: linear-gradient(135deg, #222, #3b4f8f);
      color: white;
      padding: 1rem 1rem 0.9rem;
      border-radius: 4px 4px 0 0;
      margin: -1.75rem -1.75rem 1.25rem;
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }

    .game-header h1 {
      margin: 0.2rem 0;
      font-size: 30px;
    }

    .subtitle {
      margin: 0.2rem 0 0;
      color: #e0e6ff;
      font-size: 0.9rem;
    }

    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      gap: 10px;
      flex-wrap: wrap;
    }

    .score-box {
      background: #1e4da1;
      color: #fff;
      padding: 8px 14px;
      border-radius: 6px;
      min-width: 90px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    }

    .score-label {
      font-size: 11px;
      text-transform: uppercase;
      opacity: 0.9;
      letter-spacing: 0.03em;
    }

    .score-value {
      font-size: 20px;
      font-weight: bold;
    }

    .button-group {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    button {
      background: #ffd54a; /* Dunder Mifflin yellow accent */
      color: #0d2b6b;
      border: none;
      padding: 10px 18px;
      border-radius: 4px;
      font-size: 14px;
      cursor: pointer;
      font-weight: bold;
      transition: transform 0.05s ease, box-shadow 0.1s ease, background-color 0.1s ease;
      white-space: nowrap;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
      background-color: #ffe16f;
    }

    button:active {
      transform: translateY(0);
      box-shadow: none;
    }

    .board {
      background: #1e4da1; /* dark blue border area */
      border-radius: 6px;
      padding: 10px;
      width: 100%;
      max-width: 430px;   /* slightly bigger so tiles stay inside */
      margin: 0 auto;
      display: grid;
      grid-template-rows: repeat(4, 1fr);
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
      position: relative;
      box-sizing: border-box;
    }

    .cell {
      background: #f3f3f3;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 16px;
      color: #0d2b6b;
      padding: 4px;
      text-align: center;
      line-height: 1.2;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.04);
    }

    .cell-inner {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 4px;
    }

    .character-img {
      width: 72px;
      height: 72px;
      object-fit: cover;
      border-radius: 6px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.25);
    }

    .value {
      font-size: 12px;
      opacity: 0.8;
      color: inherit;
    }

    /* Tile colors â€“ Office/blue/gold palette */
    .tile-0  { background: #e0e7f5; }
    .tile-2  { background: #eaf0ff; }
    .tile-4  { background: #dbe6ff; }
    .tile-8  { background: #f2b179; color: #f9f6f2; }
    .tile-16 { background: #f59563; color: #f9f6f2; }
    .tile-32 { background: #f67c5f; color: #f9f6f2; }
    .tile-64 { background: #f65e3b; color: #f9f6f2; }
    .tile-128  { background: #edcf72; color: #f9f6f2; }
    .tile-256  { background: #edcc61; color: #f9f6f2; }
    .tile-512  { background: #edc850; color: #f9f6f2; }
    .tile-1024 { background: #edc53f; color: #f9f6f2; }
    .tile-2048 { background: #ffd54a; color: #0d2b6b; }

    .game-over-overlay {
      position: absolute;
      inset: 0;
      background: rgba(243, 243, 243, 0.92);
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 10px;
      z-index: 10;
      border-radius: 6px;
    }

    .game-over-overlay.show {
      display: flex;
    }

    .game-over-text {
      font-size: 24px;
      font-weight: bold;
      color: #0d2b6b;
    }

    .instructions {
      margin-top: 10px;
      font-size: 13px;
      color: #0d2b6b;
    }

    @media (max-width: 500px) {
      .game-container {
        margin: 1.5rem 1rem;
      }
      .board {
        max-width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="game-container">
    <div class="game-header">
      <h1>The Office 2048</h1>
      <div class="subtitle">
        Combine the characters to climb the Dunder Mifflin food chain! Use arrow keys.
      </div>
    </div>

    <div class="top-bar">
      <div class="score-box">
        <div class="score-label">Score</div>
        <div class="score-value" id="score">0</div>
      </div>
      <div class="button-group">
        <button id="new-game">New Game</button>
        <button id="back-home">Back to Fan Page</button>
      </div>
    </div>

    <div class="board" id="board">
      <!-- Cells populated by JS -->
      <div class="game-over-overlay" id="game-over">
        <div class="game-over-text" id="game-over-text">Game Over!</div>
        <button id="try-again">Try Again</button>
      </div>
    </div>

    <div class="instructions">
      Use the arrow keys to move tiles. When two matching tiles collide, 
      they merge into a higher-level character.
    </div>
  </div>

  <script>
    // Map tile values to character images
    const characterImageMap = {
      2:    { src: "../assets/img/Kevin.jpg",   alt: "Kevin" },
      4:    { src: "../assets/img/Angela.jpg",  alt: "Angela" },
      8:    { src: "../assets/img/Oscar.jpg",   alt: "Oscar" },
      16:   { src: "../assets/img/Stanley.jpg", alt: "Stanley" },
      32:   { src: "../assets/img/Phyllis.jpg", alt: "Phyllis" },
      64:   { src: "../assets/img/Dwight.jpg",  alt: "Dwight" },
      128:  { src: "../assets/img/Jim.jpg",     alt: "Jim" },
      256:  { src: "../assets/img/Pam.jpg",     alt: "Pam" },
      512:  { src: "../assets/img/Andy.jpg",    alt: "Andy" },
      1024: { src: "../assets/img/Michael.jpg", alt: "Michael" },
      2048: { src: "../assets/img/Creed.jpg",   alt: "Creed" }
    };

    const boardSize = 4;
    let board = [];
    let score = 0;

    const boardElement = document.getElementById("board");
    const scoreElement = document.getElementById("score");
    const gameOverOverlay = document.getElementById("game-over");
    const gameOverText = document.getElementById("game-over-text");
    const newGameBtn = document.getElementById("new-game");
    const tryAgainBtn = document.getElementById("try-again");
    const backHomeBtn = document.getElementById("back-home");

    function initBoard() {
      board = [];
      for (let r = 0; r < boardSize; r++) {
        const row = [];
        for (let c = 0; c < boardSize; c++) {
          row.push(0);
        }
        board.push(row);
      }
    }

    function getEmptyCells() {
      const empties = [];
      for (let r = 0; r < boardSize; r++) {
        for (let c = 0; c < boardSize; c++) {
          if (board[r][c] === 0) {
            empties.push({ r, c });
          }
        }
      }
      return empties;
    }

    function addRandomTile() {
      const empties = getEmptyCells();
      if (empties.length === 0) return;

      const { r, c } = empties[Math.floor(Math.random() * empties.length)];
      // 90% chance for 2, 10% for 4
      board[r][c] = Math.random() < 0.9 ? 2 : 4;
    }

    function renderBoard() {
      // Clear existing visible cells (keep overlay as last child)
      const overlay = gameOverOverlay;
      boardElement.innerHTML = "";
      boardElement.appendChild(overlay);

      for (let r = 0; r < boardSize; r++) {
        for (let c = 0; c < boardSize; c++) {
          const value = board[r][c];
          const cell = document.createElement("div");
          cell.classList.add("cell", `tile-${value}`);
          
          const inner = document.createElement("div");
          inner.classList.add("cell-inner");

          if (value !== 0) {
            const info = characterImageMap[value];

            if (info) {
              const img = document.createElement("img");
              img.classList.add("character-img");
              img.src = info.src;
              img.alt = info.alt;
              inner.appendChild(img);
            } else {
              // Fallback if no image is defined for this value
              const fallback = document.createElement("div");
              fallback.textContent = value;
              inner.appendChild(fallback);
            }

            const valSpan = document.createElement("div");
            valSpan.classList.add("value");
            valSpan.textContent = value;
            inner.appendChild(valSpan);
          }

          cell.appendChild(inner);
          boardElement.appendChild(cell);
        }
      }

      scoreElement.textContent = score;
    }

    function slideRowLeft(row) {
      // Remove zeros
      const filtered = row.filter(v => v !== 0);
      const newRow = [];
      let gainedScore = 0;

      let skip = false;
      for (let i = 0; i < filtered.length; i++) {
        if (skip) {
          skip = false;
          continue;
        }

        if (i + 1 < filtered.length && filtered[i] === filtered[i + 1]) {
          const mergedValue = filtered[i] * 2;
          newRow.push(mergedValue);
          gainedScore += mergedValue;
          skip = true;
        } else {
          newRow.push(filtered[i]);
        }
      }

      while (newRow.length < boardSize) {
        newRow.push(0);
      }

      return { newRow, gainedScore };
    }

    function moveLeft() {
      let moved = false;
      let totalGain = 0;

      for (let r = 0; r < boardSize; r++) {
        const currentRow = board[r];
        const { newRow, gainedScore } = slideRowLeft(currentRow);
        if (!arraysEqual(currentRow, newRow)) {
          moved = true;
        }
        board[r] = newRow;
        totalGain += gainedScore;
      }

      if (moved) {
        score += totalGain;
        addRandomTile();
        renderBoard();
        checkGameOver();
      }
    }

    function moveRight() {
      let moved = false;
      let totalGain = 0;

      for (let r = 0; r < boardSize; r++) {
        const currentRow = board[r].slice().reverse();
        const { newRow, gainedScore } = slideRowLeft(currentRow);
        const reversed = newRow.slice().reverse();
        if (!arraysEqual(board[r], reversed)) {
          moved = true;
        }
        board[r] = reversed;
        totalGain += gainedScore;
      }

      if (moved) {
        score += totalGain;
        addRandomTile();
        renderBoard();
        checkGameOver();
      }
    }

    function transpose(matrix) {
      const result = [];
      for (let c = 0; c < boardSize; c++) {
        const col = [];
        for (let r = 0; r < boardSize; r++) {
          col.push(matrix[r][c]);
        }
        result.push(col);
      }
      return result;
    }

    function moveUp() {
      let moved = false;
      let totalGain = 0;

      let transposed = transpose(board);
      for (let r = 0; r < boardSize; r++) {
        const currentRow = transposed[r];
        const { newRow, gainedScore } = slideRowLeft(currentRow);
        if (!arraysEqual(transposed[r], newRow)) {
          moved = true;
        }
        transposed[r] = newRow;
        totalGain += gainedScore;
      }
      board = transpose(transposed);

      if (moved) {
        score += totalGain;
        addRandomTile();
        renderBoard();
        checkGameOver();
      }
    }

    function moveDown() {
      let moved = false;
      let totalGain = 0;

      let transposed = transpose(board);
      for (let r = 0; r < boardSize; r++) {
        const currentRow = transposed[r].slice().reverse();
        const { newRow, gainedScore } = slideRowLeft(currentRow);
        const reversed = newRow.slice().reverse();
        if (!arraysEqual(transposed[r], reversed)) {
          moved = true;
        }
        transposed[r] = reversed;
        totalGain += gainedScore;
      }
      board = transpose(transposed);

      if (moved) {
        score += totalGain;
        addRandomTile();
        renderBoard();
        checkGameOver();
      }
    }

    function arraysEqual(a, b) {
      if (a.length !== b.length) return false;
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) return false;
      }
      return true;
    }

    function anyMovesAvailable() {
      // If there is any empty cell, moves are available
      if (getEmptyCells().length > 0) return true;

      // Check for adjacent equal tiles
      for (let r = 0; r < boardSize; r++) {
        for (let c = 0; c < boardSize; c++) {
          const value = board[r][c];
          if (r + 1 < boardSize && board[r + 1][c] === value) return true;
          if (c + 1 < boardSize && board[r][c + 1] === value) return true;
        }
      }
      return false;
    }

    function checkGameOver() {
      // Check for 2048 tile
      let has2048 = false;
      for (let r = 0; r < boardSize; r++) {
        for (let c = 0; c < boardSize; c++) {
          if (board[r][c] === 2048) {
            has2048 = true;
            break;
          }
        }
        if (has2048) break;
      }

      if (has2048) {
        gameOverText.textContent = "You reached Creed! (2048)";
        gameOverOverlay.classList.add("show");
        return;
      }

      if (!anyMovesAvailable()) {
        gameOverText.textContent = "Game Over! No more moves.";
        gameOverOverlay.classList.add("show");
      }
    }

    function resetGame() {
      score = 0;
      gameOverOverlay.classList.remove("show");
      initBoard();
      addRandomTile();
      addRandomTile();
      renderBoard();
    }

    document.addEventListener("keydown", (e) => {
      const key = e.key;
      if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(key)) {
        e.preventDefault(); // stop arrow keys from scrolling page
      }
      switch (key) {
        case "ArrowLeft":
          moveLeft();
          break;
        case "ArrowRight":
          moveRight();
          break;
        case "ArrowUp":
          moveUp();
          break;
        case "ArrowDown":
          moveDown();
          break;
      }
    });

    newGameBtn.addEventListener("click", resetGame);
    tryAgainBtn.addEventListener("click", resetGame);

    // Back to fan page
    backHomeBtn.addEventListener("click", () => {
        // Updated to go to "Fan page.html"
        window.location.href = "Fan page.html";
    });


    // Start the game
    resetGame();
  </script>
</body>
</html>

